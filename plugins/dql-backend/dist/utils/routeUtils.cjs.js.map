{"version":3,"file":"routeUtils.cjs.js","sources":["../../src/utils/routeUtils.ts"],"sourcesContent":["/**\r\n * @license\r\n * Copyright 2024 Dynatrace LLC\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { AuthService } from '@backstage/backend-plugin-api';\r\nimport { CatalogClient } from '@backstage/catalog-client';\r\nimport { Entity } from '@backstage/catalog-model';\r\nimport {\r\n  dynatraceCatalogQuerySchema,\r\n  EntityQuery,\r\n  ExtendedEntity,\r\n} from '@dynatrace/backstage-plugin-dql-common';\r\nimport { Request } from 'express';\r\n\r\nexport const getEntityFromRequest = async (\r\n  req: Request,\r\n  client: CatalogClient,\r\n  auth: AuthService,\r\n): Promise<Entity> => {\r\n  const entityRef = req.query?.entityRef;\r\n  if (typeof entityRef !== 'string' || !entityRef) {\r\n    throw new Error('Invalid entity ref');\r\n  }\r\n\r\n  const { token } = await auth.getPluginRequestToken({\r\n    onBehalfOf: await auth.getOwnServiceCredentials(),\r\n    targetPluginId: 'catalog',\r\n  });\r\n  if (!token) {\r\n    throw new Error(`Failed to get service token`);\r\n  }\r\n\r\n  const entity = await client.getEntityByRef(entityRef, { token });\r\n  if (!entity) {\r\n    throw new Error(`Entity ref \"${entityRef}\" not found`);\r\n  }\r\n  return entity;\r\n};\r\n\r\nexport const validateQueries = (\r\n  extendedEntity: ExtendedEntity,\r\n): EntityQuery[] => {\r\n  const parsedQuery = dynatraceCatalogQuerySchema.safeParse(\r\n    extendedEntity.metadata.dynatrace?.queries,\r\n  );\r\n  if (parsedQuery.error) {\r\n    const zodError = parsedQuery.error.errors\r\n      .map(\r\n        error =>\r\n          `\"${error.message}\" at metadata/dynatrace/queries/${error.path.join(\r\n            '/',\r\n          )}`,\r\n      )\r\n      .join('\\n');\r\n    throw new Error(`Invalid custom catalog queries.\\n${zodError}`);\r\n  }\r\n  return parsedQuery.data;\r\n};\r\n"],"names":["dynatraceCatalogQuerySchema"],"mappings":";;;;AAyBO,MAAM,oBAAuB,GAAA,OAClC,GACA,EAAA,MAAA,EACA,IACoB,KAAA;AACpB,EAAM,MAAA,SAAA,GAAY,IAAI,KAAO,EAAA,SAAA,CAAA;AAC7B,EAAA,IAAI,OAAO,SAAA,KAAc,QAAY,IAAA,CAAC,SAAW,EAAA;AAC/C,IAAM,MAAA,IAAI,MAAM,oBAAoB,CAAA,CAAA;AAAA,GACtC;AAEA,EAAA,MAAM,EAAE,KAAA,EAAU,GAAA,MAAM,KAAK,qBAAsB,CAAA;AAAA,IACjD,UAAA,EAAY,MAAM,IAAA,CAAK,wBAAyB,EAAA;AAAA,IAChD,cAAgB,EAAA,SAAA;AAAA,GACjB,CAAA,CAAA;AACD,EAAA,IAAI,CAAC,KAAO,EAAA;AACV,IAAM,MAAA,IAAI,MAAM,CAA6B,2BAAA,CAAA,CAAA,CAAA;AAAA,GAC/C;AAEA,EAAA,MAAM,SAAS,MAAM,MAAA,CAAO,eAAe,SAAW,EAAA,EAAE,OAAO,CAAA,CAAA;AAC/D,EAAA,IAAI,CAAC,MAAQ,EAAA;AACX,IAAA,MAAM,IAAI,KAAA,CAAM,CAAe,YAAA,EAAA,SAAS,CAAa,WAAA,CAAA,CAAA,CAAA;AAAA,GACvD;AACA,EAAO,OAAA,MAAA,CAAA;AACT,EAAA;AAEa,MAAA,eAAA,GAAkB,CAC7B,cACkB,KAAA;AAClB,EAAA,MAAM,cAAcA,oDAA4B,CAAA,SAAA;AAAA,IAC9C,cAAA,CAAe,SAAS,SAAW,EAAA,OAAA;AAAA,GACrC,CAAA;AACA,EAAA,IAAI,YAAY,KAAO,EAAA;AACrB,IAAM,MAAA,QAAA,GAAW,WAAY,CAAA,KAAA,CAAM,MAChC,CAAA,GAAA;AAAA,MACC,WACE,CAAI,CAAA,EAAA,KAAA,CAAM,OAAO,CAAA,gCAAA,EAAmC,MAAM,IAAK,CAAA,IAAA;AAAA,QAC7D,GAAA;AAAA,OACD,CAAA,CAAA;AAAA,KACL,CACC,KAAK,IAAI,CAAA,CAAA;AACZ,IAAA,MAAM,IAAI,KAAM,CAAA,CAAA;AAAA,EAAoC,QAAQ,CAAE,CAAA,CAAA,CAAA;AAAA,GAChE;AACA,EAAA,OAAO,WAAY,CAAA,IAAA,CAAA;AACrB;;;;;"}